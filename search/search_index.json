{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"Actividad-1/","title":"\ud83d\udcda Pr\u00e1ctica 1: Control de LED con Pulsador (Entrada Digital)","text":"<p>Un proyecto fundamental para entender c\u00f3mo un microcontrolador (ESP32) lee informaci\u00f3n del mundo f\u00edsico (un bot\u00f3n) y act\u00faa sobre \u00e9l (un LED).</p>"},{"location":"Actividad-1/#1-resumen","title":"1) Resumen","text":"<ul> <li>Autor: Juan Carlos Vald\u00e9s P\u00e9rez</li> <li>Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica</li> <li>Fecha: 12/09/2025</li> <li>Placa: ESP32</li> <li>Descripci\u00f3n breve: Un circuito simple que utiliza un pulsador (push button) para controlar el encendido y apagado de un LED, demostrando el uso de pines de entrada y salida digital.</li> </ul> <p>Nota: Este proyecto es la base para cualquier sistema de control que requiera leer un interruptor, un sensor de l\u00edmite o cualquier se\u00f1al digital simple.</p>"},{"location":"Actividad-1/#2-objetivo-del-proyecto","title":"2) Objetivo del Proyecto","text":"<p>Aprender a configurar los pines de un ESP32 para dos modos diferentes:</p> <ul> <li>Modo SALIDA (OUTPUT): Para enviar voltaje y encender un LED usando la funci\u00f3n <code>digitalWrite()</code>.</li> <li>Modo ENTRADA (INPUT): Para leer el estado de un componente externo, en este caso un pulsador, usando la funci\u00f3n <code>digitalRead()</code>.</li> </ul>"},{"location":"Actividad-1/#3-componentes-y-requisitos","title":"3) Componentes y Requisitos","text":"<p>Hardware - Microcontrolador ESP32 - 1 LED (cualquier color) - 1 Resistencia de 220 Ohms (para proteger el LED) - 1 Pulsador (push button) - Protoboard y Jumpers (cables)</p> <p>Software - Arduino IDE - Lenguaje de programaci\u00f3n: C++</p>"},{"location":"Actividad-1/#4-desafios-clave-y-aprendizajes","title":"4) Desaf\u00edos Clave y Aprendizajes","text":"<p>Desaf\u00edo: El desaf\u00edo m\u00e1s com\u00fan al inicio fue entender la polaridad del LED. Al conectarlo al rev\u00e9s (\u00e1nodo y c\u00e1todo invertidos), el circuito no funcionaba aunque el c\u00f3digo estuviera perfecto.</p> <p>Aprendizaje: El aprendizaje clave fue la importancia de verificar el hardware antes de asumir que el error est\u00e1 en el software (c\u00f3digo). Tambi\u00e9n aprend\u00ed a diferenciar claramente entre <code>pinMode(INPUT)</code> y <code>pinMode(OUTPUT)</code>, que son la base para controlar casi cualquier componente.</p>"},{"location":"Actividad-1/#5-galeria-y-demostracion","title":"5) Galer\u00eda y Demostraci\u00f3n","text":""},{"location":"Actividad-2/","title":"\ud83d\udcda Pr\u00e1ctica 2: Control de LED por Bluetooth (Comunicaci\u00f3n Serial)","text":"<p>Un proyecto que introduce la comunicaci\u00f3n inal\u00e1mbrica, usando el m\u00f3dulo Bluetooth integrado del ESP32 para recibir comandos desde un tel\u00e9fono m\u00f3vil y controlar un LED.</p>"},{"location":"Actividad-2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Autor: Juan Carlos Vald\u00e9s P\u00e9rez</li> <li>Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica</li> <li>Fecha: 12/09/2025</li> <li>Plataforma: ESP32 (Bluetooth)</li> <li>Descripci\u00f3n breve: Se establece una comunicaci\u00f3n serial por Bluetooth entre un ESP32 y una app de terminal en un tel\u00e9fono Android para enviar comandos ('1' y '0') que encienden o apagan un LED.</li> </ul> <p>Nota: Este proyecto es la puerta de entrada para crear proyectos de \"Internet de las Cosas\" (IoT), control rob\u00f3tico m\u00f3vil o cualquier sistema que requiera control remoto.</p>"},{"location":"Actividad-2/#2-objetivo-del-proyecto","title":"2) Objetivo del Proyecto","text":"<p>El objetivo fue aprender los conceptos b\u00e1sicos de la comunicaci\u00f3n serial y c\u00f3mo implementarla de forma inal\u00e1mbrica usando la librer\u00eda <code>BluetoothSerial.h</code> del ESP32. El fin era recibir datos (caracteres '1' y '0') desde un dispositivo externo (tel\u00e9fono) para ejecutar acciones en el microcontrolador.</p>"},{"location":"Actividad-2/#3-componentes-y-requisitos","title":"3) Componentes y Requisitos","text":"<p>Hardware - Microcontrolador ESP32 - 1 LED (cualquier color) - 1 Resistencia de 220 Ohms - Protoboard y Jumpers (cables)</p> <p>Software - Arduino IDE - Lenguaje de programaci\u00f3n: C++ (con la librer\u00eda <code>BluetoothSerial.h</code>) - App M\u00f3vil (Android): Serial Bluetooth Terminal</p>"},{"location":"Actividad-2/#4-desafios-clave-y-aprendizajes","title":"4) Desaf\u00edos Clave y Aprendizajes","text":"<p>Desaf\u00edo: El mayor desaf\u00edo fue la compatibilidad de plataformas. Mi tel\u00e9fono personal (iOS) no era compatible con la aplicaci\u00f3n \"Serial Bluetooth Terminal\" requerida. El problema se solucion\u00f3 gracias al trabajo en equipo, utilizando el tel\u00e9fono Android de mi compa\u00f1ero para realizar la vinculaci\u00f3n Bluetooth y las pruebas de env\u00edo de comandos.</p> <p>Aprendizaje: Mi principal aprendizaje fue descubrir el potencial de una terminal serial. Antes hab\u00eda usado plataformas cerradas (como Arduino Cloud), pero vi que trabajar directamente con una terminal Bluetooth te da much\u00edsima m\u00e1s libertad y menos restricciones. Entend\u00ed que esto abre m\u00e1s posibilidades para crear interfaces de control personalizadas en el futuro.</p>"},{"location":"Actividad-2/#5-codigo-clave","title":"5) C\u00f3digo Clave","text":"<p>Aqu\u00ed est\u00e1 el fragmento de c\u00f3digo del ESP32 que \"escucha\" los datos que llegan por Bluetooth.</p>"},{"location":"Actividad-2/#include-bluetoothserialh-bluetoothserial-serialbt-byte-led-12-pin-donde-esta-conectado-el-led-void-setup-serialbegin115200-serialbtbeginel-tlacoyo-nombre-del-dispositivo-bluetooth-pinmodeled-output-void-loop-revisa-si-hay-datos-esperando-en-el-buffer-de-bluetooth-if-serialbtavailable-lee-el-dato-entrante-como-un-string-string-mensaje-serialbtreadstring-serialprintlnrecibido-mensaje-compara-el-mensaje-recibido-if-mensaje-1-digitalwriteled-1-prende-el-led-serialprintlnon-else-if-mensaje-0-digitalwriteled-0-apaga-el-led-serialprintlnoff-delay1000-pequena-pausa","title":"<pre><code>#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\nbyte led = 12; // Pin donde est\u00e1 conectado el LED\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"El Tlacoyo\"); // Nombre del dispositivo Bluetooth\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  // Revisa si hay datos esperando en el buffer de Bluetooth\n  if (SerialBT.available()) {\n    // Lee el dato entrante como un String\n    String mensaje = SerialBT.readString();\n    Serial.println(\"Recibido: \" + mensaje);\n\n    // Compara el mensaje recibido\n    if (mensaje == \"1\") {\n      digitalWrite(led, 1); // Prende el LED\n      Serial.println(\"On\");\n    } else if (mensaje == \"0\") {\n      digitalWrite(led, 0); // Apaga el LED\n      Serial.println(\"Off\");\n    }\n  }\n  delay(1000); // Peque\u00f1a pausa\n}\n</code></pre>","text":""},{"location":"Actividad-2/#6-galeria-y-demostracion","title":"6) Galer\u00eda y Demostraci\u00f3n","text":""},{"location":"Actividad-3/","title":"\ud83d\udcda Pr\u00e1ctica 3: \"Blink\" (Parpadeo B\u00e1sico de LED)","text":"<p>El \"Hola, Mundo\" del hardware. Este proyecto es el primer paso esencial para verificar que el microcontrolador (ESP32) puede ejecutar c\u00f3digo y controlar un actuador simple.</p>"},{"location":"Actividad-3/#1-resumen","title":"1) Resumen","text":"<ul> <li>Autor: Juan Carlos Vald\u00e9s P\u00e9rez</li> <li>Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica</li> <li>Fecha: 12/09/2025</li> <li>Plataforma: ESP32</li> <li>Descripci\u00f3n breve: Programa b\u00e1sico que hace parpadear un LED (encender y apagar) a intervalos de un segundo para demostrar el control de un pin de salida digital y el uso de temporizadores (<code>delay</code>).</li> </ul>"},{"location":"Actividad-3/#2-objetivo-del-proyecto","title":"2) Objetivo del Proyecto","text":"<p>El objetivo es dominar los tres comandos m\u00e1s fundamentales de la programaci\u00f3n de microcontroladores:</p> <ol> <li><code>pinMode(PIN, OUTPUT)</code>: Establecer un pin espec\u00edfico como una salida de voltaje.</li> <li><code>digitalWrite(PIN, HIGH/LOW)</code>: Enviar voltaje (encender el LED) o quitarlo (apagar el LED).</li> <li><code>delay(ms)</code>: Crear pausas en la ejecuci\u00f3n del programa para controlar el tiempo del parpadeo.</li> </ol>"},{"location":"Actividad-3/#3-componentes-y-requisitos","title":"3) Componentes y Requisitos","text":"<p>Hardware - Microcontrolador ESP32 - 1 LED (cualquier color) - 1 Resistencia de 220 Ohms (para proteger el LED) - Protoboard y Jumpers (cables)</p> <p>Software - Arduino IDE - Lenguaje de programaci\u00f3n: C++</p>"},{"location":"Actividad-3/#4-desafios-clave-y-aprendizajes","title":"4) Desaf\u00edos Clave y Aprendizajes","text":"<p>Desaf\u00edo: Aunque es un programa simple, el desaf\u00edo inicial es asegurarse de que el LED est\u00e9 conectado en la polaridad correcta (la \"pata\" larga o \u00e1nodo al pin digital, y la corta o c\u00e1todo a tierra/GND) y que la resistencia sea la adecuada para no quemar el LED.</p> <p>Aprendizaje: Este proyecto solidifica la comprensi\u00f3n del \"flujo de control\" de un programa. Entend\u00ed que el c\u00f3digo dentro del <code>void loop()</code> se ejecuta en secuencia (l\u00ednea por l\u00ednea) y se repite infinitamente.</p> <p>Mi aprendizaje m\u00e1s importante fue entender que <code>delay()</code> es una funci\u00f3n \"bloqueante\": mientras el <code>delay(1000)</code> est\u00e1 activo, el ESP32 se detiene por completo y no puede hacer nada m\u00e1s (como leer un bot\u00f3n) durante ese segundo. Esto es crucial para entender por qu\u00e9 en proyectos m\u00e1s avanzados se deben usar otros m\u00e9todos de temporizaci\u00f3n.</p>"},{"location":"Actividad-3/#5-codigo-clave","title":"5) C\u00f3digo Clave","text":"<p>Este es el c\u00f3digo completo que se carga en el ESP32 para lograr el parpadeo.</p>"},{"location":"Actividad-3/#define-el-pin-donde-esta-conectado-el-led-puedes-cambiar-12-al-pin-que-hayas-usado-ej-2-4-13-etc-byte-ledpin-12-void-setup-configura-el-pin-del-led-como-una-salida-pinmodeledpin-output-void-loop-1-enciende-el-led-pone-el-pin-en-alto-digitalwriteledpin-high-2-espera-1-segundo-1000-milisegundos-delay1000-3-apaga-el-led-pone-el-pin-en-bajo-digitalwriteledpin-low-4-espera-1-segundo-delay1000-el-loop-se-repite-desde-el-inicio","title":"<pre><code>// Define el pin donde est\u00e1 conectado el LED\n// (Puedes cambiar '12' al pin que hayas usado, ej: 2, 4, 13, etc.)\nbyte ledPin = 12; \n\nvoid setup() {\n  // Configura el pin del LED como una SALIDA\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // 1. Enciende el LED (pone el pin en ALTO)\n  digitalWrite(ledPin, HIGH);\n\n  // 2. Espera 1 segundo (1000 milisegundos)\n  delay(1000);\n\n  // 3. Apaga el LED (pone el pin en BAJO)\n  digitalWrite(ledPin, LOW);\n\n  // 4. Espera 1 segundo\n  delay(1000);\n\n  // (El loop se repite desde el inicio)\n}\n</code></pre>","text":""},{"location":"Actividad-3/#6-galeria-y-demostracion","title":"6) Galer\u00eda y Demostraci\u00f3n","text":""},{"location":"Actividad-4/","title":"\ud83d\udcda Pr\u00e1ctica 4: Control de Giro de Motor DC con Puente H","text":"<p>Este proyecto es una introducci\u00f3n fundamental a la rob\u00f3tica m\u00f3vil. Se implementa el control de la direcci\u00f3n de giro de un motor DC utilizando un driver L293D (Puente H) y un microcontrolador ESP32.</p>"},{"location":"Actividad-4/#1-resumen","title":"1) Resumen","text":"<ul> <li>Autor: Juan Carlos Vald\u00e9s P\u00e9rez</li> <li>Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica</li> <li>Fecha: 19/09/2025 </li> <li>Placa: ESP32</li> <li>Descripci\u00f3n breve: Se programa un ESP32 para enviar se\u00f1ales l\u00f3gicas a un driver L293D, el cual invierte la polaridad del voltaje suministrado a un motor DC para hacerlo girar en ambas direcciones.</li> </ul>"},{"location":"Actividad-4/#2-objetivo-del-proyecto","title":"2) Objetivo del Proyecto","text":"<p>El objetivo fue aprender a usar el driver Puente H L293D y entender su principio de funcionamiento: c\u00f3mo utiliza una l\u00f3gica de control de bajo voltaje (del ESP32) para invertir la polaridad de una fuente de alimentaci\u00f3n de mayor voltaje (para el motor) y as\u00ed controlar la direcci\u00f3n del giro.</p>"},{"location":"Actividad-4/#3-componentes-y-requisitos","title":"3) Componentes y Requisitos","text":"<p>Hardware - Microcontrolador ESP32 - 1 Motor DC (tipo \"pager\" o similar) - 1 Driver Puente H (Modelo: L293D) - Fuente de alimentaci\u00f3n variable de laboratorio (para V_motor del Puente H) - Protoboard y Jumpers</p> <p>Software - Arduino IDE - Lenguaje de programaci\u00f3n: C++</p>"},{"location":"Actividad-4/#4-desafios-clave-y-aprendizajes","title":"4) Desaf\u00edos Clave y Aprendizajes","text":"<p>Desaf\u00edo: El mayor desaf\u00edo durante el ensamblaje fue la depuraci\u00f3n de conexiones f\u00edsicas. En varias ocasiones, el circuito no funcionaba como se esperaba y, tras revisar el c\u00f3digo y las conexiones l\u00f3gicas, descubr\u00ed que el problema eran jumpers (cables) defectuosos que \"falseaban\" o no hac\u00edan buen contacto. Esto me ense\u00f1\u00f3 a no asumir que el hardware nuevo funciona perfectamente y a tener un m\u00e9todo para probar la continuidad de los cables.</p> <p>Aprendizaje: Mi principal aprendizaje fue sobre la gesti\u00f3n de energ\u00eda del L293D. Analizando el componente, descubr\u00ed que tiene una salida de 5V (V_logic) que puede usarse para alimentar al propio ESP32. Esto es \u00fatil porque permite que el microcontrolador y el driver compartan alimentaci\u00f3n desde una misma fuente (como una bater\u00eda).</p> <p>Sin embargo, tambi\u00e9n entend\u00ed la desventaja: esta configuraci\u00f3n le \"quita\" potencia a los motores (ya que la potencia total se divide) y puede agotar la bater\u00eda m\u00e1s r\u00e1pidamente.</p>"},{"location":"Actividad-4/#5-codigo-clave","title":"5) C\u00f3digo Clave","text":"<p>Este fragmento de c\u00f3digo muestra la l\u00f3gica b\u00e1sica para controlar el giro. Se usan dos pines del ESP32 (<code>in1</code> e <code>in2</code>) para dictar la direcci\u00f3n del motor.</p>"},{"location":"Actividad-4/#define-in1-18-define-in2-19-define-pwm-21-void-setup-put-your-setup-code-here-to-run-once-pinmodein1output-pinmodein2output-ledcattachpwm10008-void-loop-put-your-main-code-here-to-run-repeatedly-forint-i0-i-255-i-ledcwritepwmi-digitalwritein11-digitalwritein20-delay400-digitalwritein10-digitalwritein10-delay200-digitalwritein10-digitalwritein11-delay400","title":"<pre><code>#define in1 18\n#define in2 19\n#define pwm 21\n\n\nvoid setup() {\n  // put your setup code here, to run once:\npinMode(in1,OUTPUT);\npinMode(in2,OUTPUT);\nledcAttach(pwm,1000,8);\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\nfor(int i=0; i &lt;= 255; i++){\n  ledcWrite(pwm,i);;\n}\n\ndigitalWrite(in1,1);\ndigitalWrite(in2,0);\ndelay(400);\ndigitalWrite(in1,0);\ndigitalWrite(in1,0);\ndelay(200);\ndigitalWrite(in1,0);\ndigitalWrite(in1,1);\ndelay(400);\n}\n</code></pre>","text":""},{"location":"Actividad-4/#6-galeria-y-demostracion","title":"6) Galer\u00eda y Demostraci\u00f3n","text":""},{"location":"Actividad-5/","title":"\ud83d\udcda Pr\u00e1ctica 5: Aceleraci\u00f3n Suave con ESP32 y Puente H","text":"<p>Este proyecto avanza del control ON/OFF al control anal\u00f3gico. Se implementa una se\u00f1al de Modulaci\u00f3n por Ancho de Pulso (PWM) para controlar la velocidad de un motoreductor DC, logrando una aceleraci\u00f3n y desaceleraci\u00f3n fluida.</p>"},{"location":"Actividad-5/#1-resumen","title":"1) Resumen","text":"<ul> <li>Autor: Juan Carlos Vald\u00e9s P\u00e9rez</li> <li>Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica</li> <li>Fecha: 19/09/2025</li> <li>Placa: ESP32 (Controlador LEDC PWM)</li> <li>Descripci\u00f3n breve: Se programa un ESP32 para generar una se\u00f1al PWM que alimenta el pin \"Enable\" de un Puente H L293D. El c\u00f3digo incrementa y disminuye el ciclo de trabajo (duty cycle) progresivamente para hacer que un motoreductor DC acelere y frene suavemente.</li> </ul>"},{"location":"Actividad-5/#2-objetivo-del-proyecto","title":"2) Objetivo del Proyecto","text":"<p>Aprender el concepto fundamental de PWM (Modulaci\u00f3n por Ancho de Pulso) y c\u00f3mo utilizar las funciones espec\u00edficas del ESP32 (<code>ledcAttach</code> y <code>ledcWrite</code>) para controlar con precisi\u00f3n la potencia entregada a un motor.</p>"},{"location":"Actividad-5/#3-componentes-y-requisitos","title":"3) Componentes y Requisitos","text":"<p>Hardware - Microcontrolador ESP32 - 1 Motoreductor DC (amarillo, con caja reductora) - 1 Driver Puente H (Modelo: L293D) - Fuente de alimentaci\u00f3n externa - Protoboard y Jumpers</p> <p>Software - Arduino IDE - Lenguaje de programaci\u00f3n: C++ (utilizando las funciones del controlador LEDC del ESP32)</p>"},{"location":"Actividad-5/#4-desafios-clave-y-aprendizajes","title":"4) Desaf\u00edos Clave y Aprendizajes","text":"<p>Desaf\u00edo: El desaf\u00edo principal fue el c\u00f3digo para la fluidez. En las primeras pruebas, el motor cambiaba de velocidad, pero lo hac\u00eda de forma brusca y a \"saltos\". El reto fue encontrar la l\u00f3gica correcta en el programa para que el incremento de potencia fuera gradual. Esto se solucion\u00f3 implementando bucles <code>for</code> que modifican el valor del PWM paso a paso (de 0 a 255 y viceversa), logrando el efecto de \"rampa\" deseado.</p> <p>Aprendizaje: Tuve dos aprendizajes clave en esta pr\u00e1ctica:</p> <ol> <li> <p>Conceptual (Qu\u00e9 es PWM): Entend\u00ed que el PWM no \"baja el voltaje\" m\u00e1gicamente. Es una t\u00e9cnica digital que enciende y apaga la energ\u00eda a muy alta frecuencia (en este caso, 1000 veces por segundo). Al cambiar el ancho de esos pulsos (el \"ciclo de trabajo\"), se controla la potencia promedio que recibe el motor, simulando un voltaje anal\u00f3gico.</p> </li> <li> <p>T\u00e9cnico (PWM en ESP32): Aprend\u00ed que el ESP32 es m\u00e1s avanzado que un Arduino Uno. No usa la funci\u00f3n <code>analogWrite()</code>. En su lugar, tiene controladores LEDC dedicados. Se debe primero \"configurar un canal\" de PWM (con <code>ledcAttach</code>) y luego \"escribir\" el valor de potencia en ese canal (con <code>ledcWrite</code>).</p> </li> </ol>"},{"location":"Actividad-5/#5-codigo-clave","title":"5) C\u00f3digo Clave","text":"<p>Este es el c\u00f3digo principal cargado en el ESP32. Se definen los pines de direcci\u00f3n (<code>in1</code>, <code>in2</code>) y un pin para la se\u00f1al PWM (<code>pwm</code>). Los bucles <code>for</code> se encargan de aumentar y disminuir el ciclo de trabajo de 0 a 255.</p>"},{"location":"Actividad-5/#-pines-de-control-pines-para-la-direccion-del-motor-define-in1-25-define-in2-26-pin-para-la-velocidad-conectado-al-enable-del-puente-h-define-pwm-27-configuracion-del-canal-pwm-frecuencia-de-la-senal-pwm-1000-hz-int-frecuenciapwm-1000-canal-pwm-que-usaremos-de-0-a-15-int-canalpwm-0-resolucion-en-bits-8-bits-0-a-255-int-resolucion-8-void-setup-configurar-pines-de-direccion-como-salida-pinmodein1-output-pinmodein2-output-configurar-el-canal-pwm-con-ledcattach-canal-frecuencia-resolucion-ledcattachcanalpwm-frecuenciapwm-resolucion-vincular-el-pin-pwm-27-al-canal-que-configuramos-ledcattachpinpwm-canalpwm-void-loop-bucle-de-aceleracion-incrementa-i-desde-0-0-potencia-hasta-255-100-potencia-for-int-i-0-i-255-i-escribe-el-valor-actual-de-i-en-el-canal-pwm-ledcwritecanalpwm-i-fija-la-direccion-ej-adelante-digitalwritein1-1-digitalwritein2-0-pequena-pausa-para-ver-el-efecto-delay10-bucle-de-desaceleracion-decrementa-i-desde-255-100-potencia-hasta-0-0-potencia-for-int-i-255-i-0-i-escribe-el-valor-actual-de-i-en-el-canal-pwm-ledcwritecanalpwm-i-mantiene-la-direccion-digitalwritein1-1-digitalwritein2-0-pequena-pausa-delay10","title":"<pre><code>// --- Pines de Control ---\n// Pines para la DIRECCI\u00d3N del motor\n#define in1 25\n#define in2 26\n// Pin para la VELOCIDAD (conectado al 'Enable' del Puente H)\n#define pwm 27\n\n// --- Configuraci\u00f3n del Canal PWM ---\n// Frecuencia de la se\u00f1al PWM (1000 Hz)\nint frecuenciaPWM = 1000;\n// Canal PWM que usaremos (de 0 a 15)\nint canalPWM = 0;\n// Resoluci\u00f3n en bits (8 bits = 0 a 255)\nint resolucion = 8;\n\n\nvoid setup() {\n  // Configurar pines de direcci\u00f3n como SALIDA\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n\n  // Configurar el canal PWM con ledcAttach\n  // (canal, frecuencia, resoluci\u00f3n)\n  ledcAttach(canalPWM, frecuenciaPWM, resolucion);\n\n  // Vincular el pin 'pwm' (27) al canal que configuramos\n  ledcAttachPin(pwm, canalPWM);\n}\n\nvoid loop() {\n  // --- Bucle de Aceleraci\u00f3n ---\n  // Incrementa 'i' desde 0 (0% potencia) hasta 255 (100% potencia)\n  for (int i = 0; i &lt;= 255; i++) {\n    // Escribe el valor actual de 'i' en el canal PWM\n    ledcWrite(canalPWM, i);\n    // Fija la direcci\u00f3n (ej. \"adelante\")\n    digitalWrite(in1, 1);\n    digitalWrite(in2, 0);\n    // Peque\u00f1a pausa para ver el efecto\n    delay(10);\n  }\n\n  // --- Bucle de Desaceleraci\u00f3n ---\n  // Decrementa 'i' desde 255 (100% potencia) hasta 0 (0% potencia)\n  for (int i = 255; i &gt;= 0; i--) {\n    // Escribe el valor actual de 'i' en el canal PWM\n    ledcWrite(canalPWM, i);\n    // Mantiene la direcci\u00f3n\n    digitalWrite(in1, 1);\n    digitalWrite(in2, 0);\n    // Peque\u00f1a pausa\n    delay(10);\n  }\n}\n</code></pre>","text":""},{"location":"Actividad-5/#6-galeria-y-demostracion","title":"6) Galer\u00eda y Demostraci\u00f3n","text":""},{"location":"Actividad-6/","title":"\ud83d\udcda Pr\u00e1ctica 6: Control de Posici\u00f3n con Servomotor SG90","text":"<p>Este proyecto completa la trilog\u00eda de control de actuadores. Se implementa el control de posici\u00f3n angular de un servomotor SG90, orden\u00e1ndole moverse a \u00e1ngulos espec\u00edficos entre 0\u00b0 y 180\u00b0.</p>"},{"location":"Actividad-6/#1-resumen","title":"1) Resumen","text":"<ul> <li>Autor: Juan Carlos Vald\u00e9s P\u00e9rez</li> <li>Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica</li> <li>Fecha: 26/09/2025</li> <li>Placa: ESP32 (Controlador LEDC PWM)</li> <li>Descripci\u00f3n breve: Se programa un ESP32 para generar una se\u00f1al PWM muy espec\u00edfica (50Hz) que le ordena a un servomotor SG90 moverse progresivamente en pasos de 10 grados, realizando un barrido de 0\u00b0 a 180\u00b0.</li> </ul>"},{"location":"Actividad-6/#2-objetivo-del-proyecto","title":"2) Objetivo del Proyecto","text":"<ul> <li>Aprender a controlar el \u00e1ngulo (posici\u00f3n) de un servomotor.</li> <li>Entender c\u00f3mo una se\u00f1al PWM de frecuencia fija (50Hz) se utiliza para enviar comandos posicionales, a diferencia del PWM de alta frecuencia usado para controlar la velocidad de un motor DC.</li> </ul>"},{"location":"Actividad-6/#3-componentes-y-requisitos","title":"3) Componentes y Requisitos","text":"<p>Hardware - Microcontrolador ESP32 - 1 Servomotor SG90 (azul) - Protoboard y Jumpers</p> <p>Software - Arduino IDE - Lenguaje de programaci\u00f3n: C++ (utilizando las funciones del controlador LEDC del ESP32)</p>"},{"location":"Actividad-6/#4-desafios-clave-y-aprendizajes","title":"4) Desaf\u00edos Clave y Aprendizajes","text":"<p>Desaf\u00edo: El desaf\u00edo principal fue conceptual: entender por qu\u00e9 se usa una frecuencia de 50Hz y no otra. A diferencia del PWM para motores DC (donde 1000Hz o m\u00e1s es com\u00fan para evitar zumbidos), los servomotores son un est\u00e1ndar industrial. Aprend\u00ed que 50Hz (lo que equivale a un pulso cada 20 milisegundos) es la norma que estos motores \"esperan\" para interpretar la se\u00f1al. Enviar una frecuencia incorrecta (como 1000Hz) simplemente no funciona, ya que el servo no puede entender los comandos.</p> <p>Aprendizaje: Tuve dos aprendizajes clave que resumen estas \u00faltimas pr\u00e1cticas:</p> <ol> <li>Conceptual (Servos vs. Motor DC): Entend\u00ed que un motor DC y un servomotor son fundamentalmente diferentes, aunque ambos giran. Un motor DC es para velocidad y giro continuo (controlas la potencia con PWM). Un servomotor es para posici\u00f3n y giro limitado (controlas el \u00e1ngulo con el ancho del pulso en una frecuencia fija).</li> <li>T\u00e9cnico (Funci\u00f3n <code>map()</code>): Aprend\u00ed a usar la funci\u00f3n <code>map()</code> de Arduino. Es una herramienta incre\u00edblemente \u00fatil para escalar (o \"mapear\") un rango de n\u00fameros a otro. En este caso, fue perfecta para convertir mi rango de \u00e1ngulos (0\u00b0 a 180\u00b0) al rango de \"duty cycle\" que el servo entiende (que calculamos ser de 205 a 410).</li> </ol>"},{"location":"Actividad-6/#5-codigo-clave","title":"5) C\u00f3digo Clave","text":"<p>Este es el c\u00f3digo principal. La parte m\u00e1s importante es el c\u00e1lculo matem\u00e1tico: un servo se controla con un pulso de 1ms (0\u00b0) a 2ms (180\u00b0). A 50Hz y 12 bits de resoluci\u00f3n (4096 pasos), 1ms es ~5% (valor 205) y 2ms es ~10% (valor 410).</p> <pre><code>/*Control de 1 solo servomotor*/\n#define pwmPin 12  //Pin del ESP32 a la se\u00f1al del servo\n\n// --- Valores Clave para el Servo ---\n// Frecuencia est\u00e1ndar para servos\nint frecuenciaPWM = 50;  // 50 Hz (o un pulso cada 20ms)\n// Canal PWM que usaremos (de 0 a 15)\nint canalPWM = 0;\n// Resoluci\u00f3n de 12 bits (0 a 4095)\nint resolucion = 12;\n\n// Valores de \"Duty Cycle\" calculados\n// 0\u00b0   = 1ms de pulso = 5% de 20ms = 5% de 4096 = 205\nint minDuty = 205; \n// 180\u00b0 = 2ms de pulso = 10% de 20ms = 10% de 4096 = 410\nint maxDuty = 410;\n\nvoid setup() {\n  Serial.begin(115200);\n\n  /*Configuracion de canal PWM \n    - Frecuencia de 50hz\n    - Resolucion de 12 bit (0-4095)\n    - Canal 0\n  */\n  ledcSetup(canalPWM, frecuenciaPWM, resolucion);\n\n  // Asignar el pin (12) al canal (0)\n  ledcAttachPin(pwmPin, canalPWM);\n}\n\nvoid loop() {\n  Serial.println(\"Iniciando barrido progresivo (0 -&gt; 180)...\");\n\n  // Bucle para ir de 0 a 180 grados, en pasos de 10\n  for (int angulo = 0; angulo &lt;= 180; angulo += 10) {\n\n    // Mapear el \u00e1ngulo (0-180) al valor de duty cycle (205-410)\n    int duty = map(angulo, 0, 180, minDuty, maxDuty);\n\n    Serial.print(\"Angulo: \");\n    Serial.print(angulo);\n    Serial.print(\" - Duty Cycle: \");\n    Serial.println(duty);\n\n    // Enviar el pulso al servo\n    ledcWrite(canalPWM, duty);\n\n    // Pausa de medio segundo antes del siguiente paso\n    delay(500);\n  }\n\n  // Pausa de 2 segundos al llegar a 180\n  delay(2000); \n\n  // (Aqu\u00ed se podr\u00eda agregar un 'for' loop para regresar de 180 a 0)\n}\n</code></pre>"},{"location":"Actividad-6/#6-galeria-y-demostracion","title":"6) Galer\u00eda y Demostraci\u00f3n","text":""},{"location":"OpenCV_1-Eliminar%20colores/","title":"\ud83c\udfa8 [Fundamentos de Visi\u00f3n Artificial: Colores y Figuras]","text":"<p>Introducci\u00f3n a la manipulaci\u00f3n de canales de color y dibujo de primitivas en tiempo real.</p>"},{"location":"OpenCV_1-Eliminar%20colores/#objetivo-principal","title":"\ud83c\udfaf Objetivo Principal","text":"<p>El prop\u00f3sito de esta pr\u00e1ctica fue introducirme en el procesamiento de im\u00e1genes con OpenCV. El objetivo espec\u00edfico fue aprender a descomponer una imagen de video en sus canales de color fundamentales (Azul, Verde, Rojo) para manipularlos individualmente, adem\u00e1s de entender el sistema de coordenadas de la imagen para dibujar figuras geom\u00e9tricas y realizar animaciones sencillas.</p>"},{"location":"OpenCV_1-Eliminar%20colores/#demostracion","title":"\ud83d\udcf8 Demostraci\u00f3n","text":"<p>En la siguiente imagen se observa la manipulaci\u00f3n de canales en tiempo real. Se eliminaron los componentes Azul y Verde (dejando solo el Rojo) y se dibuj\u00f3 una regi\u00f3n \"ciega\" (cuadro negro).</p> <p> </p>"},{"location":"OpenCV_1-Eliminar%20colores/#tecnologias-y-librerias","title":"\ud83d\udee0\ufe0f Tecnolog\u00edas y Librer\u00edas","text":"<p>Software: * Python 3: Lenguaje principal. * OpenCV (<code>cv2</code>): Para la captura de video, conversiones de color y dibujo. * NumPy: Para la manipulaci\u00f3n eficiente de las matrices de la imagen (arrays).</p> <p>Hardware: * C\u00e1mara Web (Webcam integrada o externa).</p>"},{"location":"OpenCV_1-Eliminar%20colores/#logica-y-procesamiento","title":"\ud83c\udfd7\ufe0f L\u00f3gica y Procesamiento","text":"<p>El programa opera dentro de un bucle infinito (<code>while True</code>) procesando cada fotograma capturado:</p> <ol> <li> <p>Conversi\u00f3n de Espacios de Color:</p> <ul> <li>OpenCV captura nativamente en BGR.</li> <li>Se realizaron conversiones a RGB (para visualizaci\u00f3n est\u00e1ndar) y Escala de Grises (<code>COLOR_BGR2GRAY</code>) para simplificar el procesamiento.</li> </ul> </li> <li> <p>Dibujo y Animaci\u00f3n:</p> <ul> <li>L\u00ednea: Se dibuja una l\u00ednea est\u00e1tica negra usando <code>cv2.line</code>.</li> <li>C\u00edrculo Animado: Se dibuja un c\u00edrculo usando <code>cv2.circle</code>. Su posici\u00f3n en X (<code>centrox</code>) se incrementa en cada iteraci\u00f3n del bucle, creando una animaci\u00f3n de desplazamiento horizontal. Al llegar al l\u00edmite (300px), se reinicia.</li> </ul> </li> <li> <p>Filtrado de Canales (La \"Magia\" de los Arrays):</p> <ul> <li>Se accede directamente a la matriz de la imagen para \"apagar\" canales espec\u00edficos.</li> <li><code>img[:, :, 0] = 0</code>: Elimina el canal Azul.</li> <li><code>img[:, :, 1] = 0</code>: Elimina el canal Verde.</li> <li>Resultado: La imagen resultante (<code>no_blue</code>) se ve roja. Tambi\u00e9n se cre\u00f3 una Regi\u00f3n de Inter\u00e9s (ROI) negra poniendo todos los valores a 0 en un rango de pixeles <code>[0:300, 0:300]</code>.</li> </ul> </li> </ol>"},{"location":"OpenCV_1-Eliminar%20colores/#el-codigo","title":"\ud83d\udcbb El C\u00f3digo","text":"<pre><code>import cv2\n\n# Iniciar captura de video (0 = webcam predeterminada)\nvideo = cv2.VideoCapture(0)\n\n# Variables para la animaci\u00f3n\ncentrox = 0\ncentroy = 0\n\nwhile True:\n    ret, img = video.read()\n\n    if not ret:\n        break\n\n    # --- 1. Conversiones de Color ---\n    image1_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    image2_rgb = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)\n    image3_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # Escala de grises\n\n    cv2.imshow(\"MyVideoOG\", img)\n\n    # --- 2. Dibujo y Animaci\u00f3n ---\n    draw = img.copy()\n    # L\u00ednea est\u00e1tica\n    cv2.line(draw, (0,0), (100,100), (0,0,0), thickness=3, lineType=cv2.LINE_AA)\n    # C\u00edrculo en movimiento (usa la variable centrox)\n    cv2.circle(draw, (centrox, centroy), 100, (0,0,0), thickness=3, lineType=cv2.LINE_AA)\n\n    cv2.imshow(\"MyVideodraw\", draw)\n\n    # L\u00f3gica de movimiento del c\u00edrculo\n    if centrox &lt; 300:\n        centrox = centrox + 1\n    else:\n        centrox = 0\n\n    # --- 3. Manipulaci\u00f3n de Canales (Filtro Rojo) ---\n    no_blue = img.copy()\n    no_blue[:, :, 1] = 0  # Eliminar canal Verde (Green)\n    no_blue[:, :, 0] = 0  # Eliminar canal Azul (Blue)\n\n    # Crear un cuadro negro (ROI) en la esquina\n    no_blue[0:300, 0:300, 2] = 0 \n\n    # --- 4. Visualizaci\u00f3n ---\n    cv2.imshow(\"MyVideo1\", image1_rgb)\n    cv2.imshow(\"MyVideo2\", image2_rgb)\n    cv2.imshow(\"MyVideo3\", image3_rgb)\n    cv2.imshow(\"MyVideoCOLOR\", no_blue)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nvideo.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"OpenCV_2-Deteccion%20de%20cara/","title":"\ud83e\udd16 [Visi\u00f3n Artificial: Detecci\u00f3n de Rostros con DNN]","text":"<p>Implementaci\u00f3n de redes neuronales (SSD) pre-entrenadas para detecci\u00f3n facial de alta precisi\u00f3n.</p>"},{"location":"OpenCV_2-Deteccion%20de%20cara/#objetivo-principal","title":"\ud83c\udfaf Objetivo Principal","text":"<p>El objetivo de esta pr\u00e1ctica fue avanzar m\u00e1s all\u00e1 del procesamiento de im\u00e1genes b\u00e1sico y adentrarme en el Deep Learning. Espec\u00edficamente, aprend\u00ed a utilizar el m\u00f3dulo <code>dnn</code> (Deep Neural Networks) de OpenCV para cargar un modelo Caffe pre-entrenado. Esto resuelve el problema de la detecci\u00f3n de rostros con mucha mayor robustez y estabilidad que los m\u00e9todos antiguos (como Haar Cascades), incluso en condiciones de luz variable o \u00e1ngulos dif\u00edciles.</p>"},{"location":"OpenCV_2-Deteccion%20de%20cara/#demostracion","title":"\ud83d\udcf8 Demostraci\u00f3n","text":"<p>En la imagen se observa c\u00f3mo el algoritmo identifica el rostro del usuario y dibuja una \"Bounding Box\" (caja delimitadora) verde, mostrando adem\u00e1s el nivel de confianza (probabilidad) de que sea una cara (en este caso, 100% o 1.0000).</p> <p></p>"},{"location":"OpenCV_2-Deteccion%20de%20cara/#tecnologias-y-librerias","title":"\ud83d\udee0\ufe0f Tecnolog\u00edas y Librer\u00edas","text":"<p>Software: * Python 3 * OpenCV (<code>cv2</code>): Espec\u00edficamente el m\u00f3dulo <code>cv2.dnn</code>. * NumPy: Para operaciones matem\u00e1ticas con las detecciones.</p> <p>Modelos de IA (Archivos externos): * <code>deploy.prototxt</code>: La arquitectura de la red neuronal. * <code>res10_300x300...caffemodel</code>: Los \"pesos\" o el entrenamiento de la red (Single Shot Detector - SSD).</p>"},{"location":"OpenCV_2-Deteccion%20de%20cara/#logica-y-procesamiento","title":"\ud83c\udfd7\ufe0f L\u00f3gica y Procesamiento","text":"<p>El c\u00f3digo sigue un flujo de inferencia de red neuronal:</p> <ol> <li>Carga del Modelo: Se inicia la red (<code>net</code>) cargando la arquitectura y el modelo entrenado desde archivos externos.</li> <li>Pre-procesamiento (Blob):<ul> <li>Las redes neuronales no leen im\u00e1genes \"normales\", necesitan un \"Blob\".</li> <li>La funci\u00f3n <code>cv2.dnn.blobFromImage</code> se encarga de redimensionar la imagen a 300x300 p\u00edxeles y realizar la resta media (<code>mean subtraction</code>) de los canales de color (104, 117, 123) para normalizar la iluminaci\u00f3n.</li> </ul> </li> <li>Inferencia (Detecci\u00f3n):<ul> <li>Se pasa el blob a la red y se obtiene una lista de detecciones.</li> </ul> </li> <li>Filtrado y Dibujo:<ul> <li>Se recorren todas las detecciones encontradas.</li> <li>Filtro: Solo se toman en cuenta aquellas cuya \"confianza\" (confidence) sea mayor al 99% (<code>0.99</code>).</li> <li>Escalado: Las coordenadas que entrega la red est\u00e1n normalizadas (de 0 a 1), por lo que se multiplican por el ancho y alto original del video para saber d\u00f3nde dibujar el cuadro en la pantalla.</li> </ul> </li> </ol>"},{"location":"OpenCV_2-Deteccion%20de%20cara/#el-codigo","title":"\ud83d\udcbb El C\u00f3digo","text":"<pre><code>import cv2\nimport numpy as np\n\n# Iniciar captura de video\nvideo = cv2.VideoCapture(0)\n\n# --- Configuraci\u00f3n del Modelo ---\n# Valores medios de los canales de color (para normalizaci\u00f3n)\nmean = [104, 117, 123]\nscale = 1.0\nin_width = 300\nin_height = 300\n\n# Umbral de confianza (Solo mostrar si est\u00e1 99% seguro de que es una cara)\ndetection_threshold = 0.99\n\n# Cargar la red neuronal desde los archivos del modelo Caffe\nnet = cv2.dnn.readNetFromCaffe('models/deploy.prototxt', 'models/res10_300x300_ssd_iter_140000.caffemodel')\n\ndef detect(frame, net, scale, in_width, in_height):\n    h = frame.shape[0]\n    w = frame.shape[1]\n\n    # Convertir la imagen a un \"blob\" (formato que entiende la red neuronal)\n    blob = cv2.dnn.blobFromImage(frame, scalefactor=scale, \n                                 size=(in_width, in_height), mean=mean, swapRB=False, crop=False)\n\n    # Pasar el blob a la red\n    net.setInput(blob)\n    # Obtener las detecciones (Forward pass)\n    detections = net.forward()\n\n    # Procesar las detecciones encontradas\n    for i in range(detections.shape[2]):\n        confidence = detections[0, 0, i, 2]\n\n        # Filtrar detecciones d\u00e9biles\n        if confidence &gt; detection_threshold:\n\n            # Extraer las coordenadas del bounding box y escalarlas al tama\u00f1o original\n            box = detections[0, 0, i, 3:7] * np.array([w, h, w, h])\n            (x1, y1, x2, y2) = box.astype('int')\n\n            # Dibujar el rect\u00e1ngulo verde\n            cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)\n\n            # Etiqueta con el % de confianza\n            label = 'Confidence: %.4f' % confidence\n            label_size, base_line = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 1)\n\n            # Fondo blanco para el texto\n            cv2.rectangle(frame, (x1, y1 - label_size[1]), (x1 + label_size[0], y1 + base_line),\n                          (255, 255, 255), cv2.FILLED)\n            # Texto\n            cv2.putText(frame, label, (x1, y1), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0))\n\n    return frame\n\nwhile True:\n    ret, img = video.read()\n\n    if not ret:\n        break\n\n    # Llamar a la funci\u00f3n de detecci\u00f3n\n    img2 = detect(img, net, scale, in_width, in_height)    \n\n    cv2.imshow('DETECCION', img2)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nvideo.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"Presentaci%C3%B3n/","title":"Presentaci\u00f3n","text":""},{"location":"Presentaci%C3%B3n/#1-acerca-de-mi","title":"1) Acerca de m\u00ed","text":"<ul> <li>Nombre del proyecto: P\u00e1gina Github </li> <li>Autor: Juan Carlos Vald\u00e9s P\u00e9rez </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatr\u00f3nica </li> <li>Fecha: 29/08/2025 </li> <li>Descripci\u00f3n breve: Soy Juan Carlos, el hermano de el medio de 3. Soy alegre, amigable y comprometido</li> <li>Me gusta la rob\u00f3tica, la electr\u00f3nica, circuitos, la tecnolog\u00eda y la innovaci\u00f3n</li> <li>Estudio 1er Semestre de ingenier\u00eda mecatr\u00f3nica</li> <li>Me enfoco en la implementaci\u00f3n de tarjetas o placas de desarrollo en prototipos y el armado de los circuitos de estos</li> </ul>"},{"location":"Presentaci%C3%B3n/#2-logroshistorial","title":"2) Logros/Historial","text":"<ul> <li>He creado un contador digital de personas mediante un esp32 y una matriz led para tener un registro eficiente de personas comiendo en un stand de tacos, de esta forma se pudieron obtener datos precisos para realizar una tesina y saber el flujo de clientes cada 15 minutos para encontrar a que hora del d\u00eda hay m\u00e1s clientes</li> <li>He desarrollado un carro omnidireccional controlado por brazo o mano mediante un giroscopio, este proyecto utilizo: 2 esp32, llantas omnidireccionales, 4 motoresdc, 2 puente h y un mpu6050</li> <li>Gane una competencia de minisumos aut\u00f3nomos construidos y programados desde 0 en el Colegio Americano de Tabasco</li> </ul>"},{"location":"Presentaci%C3%B3n/#4-habilidades","title":"4) Habilidades","text":"<ul> <li> <p>Programaci\u00f3n:</p> <ul> <li>C++</li> <li>Arduino IDE</li> </ul> </li> <li> <p>Placas:</p> <ul> <li>Arduino</li> <li>Esp32</li> <li>Rasberry pi pico</li> </ul> </li> </ul>"},{"location":"Presentaci%C3%B3n/#5-idiomas","title":"5) Idiomas","text":"<ul> <li>Espa\u00f1ol (nativo)</li> <li>Ingl\u00e9s B1</li> </ul>"},{"location":"Presentaci%C3%B3n/#6-extracurricular","title":"6) Extracurricular","text":"<ul> <li>Taekwondo</li> <li>M\u00fasica</li> <li>Guitarra</li> <li>Cursos<ul> <li>academic action</li> <li>p4hbionics</li> <li>ICEMEXICO</li> </ul> </li> <li>Investigaciones de rob\u00f3tica</li> </ul>"},{"location":"Presentaci%C3%B3n/#7-contacto","title":"7) Contacto","text":"<ul> <li>Correo: juancvp06@hotmail.com</li> <li>Correo institucional: 204819@iberopuebla.mx</li> <li>Tel\u00e9fono: 9935173422 </li> <li>instagram: juankasz_vp</li> </ul>"},{"location":"Vision%20ppor%20computadora/","title":"Robot con Visi\u00f3n por Computadora y Control PID","text":""},{"location":"Vision%20ppor%20computadora/#descripcion-general","title":"Descripci\u00f3n General","text":"<p>Este proyecto consiste en un robot balanceador con plataforma m\u00f3vil, controlado mediante visi\u00f3n por computadora (OpenCV) y estabilizado con dos servomotores MG996R. El sistema detecta una pelota azul sobre una plataforma negra y ajusta la inclinaci\u00f3n mediante un control PID en tiempo real.</p> <p>El robot fue construido utilizando:</p> <ul> <li>2 servomotores MG996R de 15 kg</li> <li>Estructura y articulaciones impresas en 3D</li> <li>Plataforma de MDF</li> <li>ESP32 con comunicaci\u00f3n por Bluetooth</li> <li>Python + OpenCV para visi\u00f3n por computadora</li> </ul>"},{"location":"Vision%20ppor%20computadora/#autores","title":"Autores","text":"<ul> <li>Eduardo Salamanca</li> <li>Juan Carlos P\u00e9rez</li> <li>Andr\u00e9 S\u00e1nchez</li> <li>Sebasti\u00e1n S\u00e1nchez</li> </ul>"},{"location":"Vision%20ppor%20computadora/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Detecci\u00f3n de plataforma negra mediante segmentaci\u00f3n HSV.</li> <li>Detecci\u00f3n de pelota azul y c\u00e1lculo preciso del centro.</li> <li>Control PID ajustable en tiempo real mediante sliders en OpenCV.</li> <li>Comunicaci\u00f3n serial Bluetooth con ESP32.</li> <li>Movimientos suaves gracias a filtros y suavizado.</li> </ul>"},{"location":"Vision%20ppor%20computadora/#videos-de-funcionamiento","title":"Videos de funcionamiento","text":"<p>Video demostrativo del robot</p> <p>Demostraci\u00f3n del sistema detectando la pelota, calculando la posici\u00f3n y moviendo los servomotores en tiempo real.</p>"},{"location":"Vision%20ppor%20computadora/#hardware-utilizado","title":"Hardware Utilizado","text":"Componente Cant. Nota Servomotor MG996R 2 15 kg torque ESP32 1 Control y comunicaci\u00f3n Plataforma MDF 1 Soporte f\u00edsico Base de servos  MDF 1 Soporte f\u00edsico Piezas impresas en 3D 4+ Articulaciones y brazos Plataforma MDF 1 Soporte f\u00edsico"},{"location":"Vision%20ppor%20computadora/#software-utilizado","title":"Software Utilizado","text":"<ul> <li>Python 3.10+</li> <li>OpenCV</li> <li>NumPy</li> <li>PySerial</li> <li>Arduino IDE</li> </ul>"},{"location":"Vision%20ppor%20computadora/#funcionamiento","title":"Funcionamiento","text":""},{"location":"Vision%20ppor%20computadora/#1-deteccion-de-plataforma","title":"1. Detecci\u00f3n de Plataforma","text":"<p>Se segmenta el \u00e1rea negra mediante un threshold en HSV:</p> <p>python lower_black = np.array([0, 0, 0]) upper_black = np.array([180, 255, THRESHOLD_PLATAFORMA])</p> <p>Se obtiene el contorno m\u00e1s grande y su centro.</p>"},{"location":"Vision%20ppor%20computadora/#2-deteccion-de-pelota-azul","title":"2. Detecci\u00f3n de Pelota Azul","text":"<p>python LOW_BLUE = np.array([100, 150, 70]) HIGH_BLUE = np.array([130, 255, 255])</p> <p>Se calcula centro y radio para validar detecci\u00f3n.</p>"},{"location":"Vision%20ppor%20computadora/#3-calculo-de-error","title":"3. C\u00e1lculo de Error","text":"<p>python error_x = centro_pelota.x - centro_plataforma.x error_y = centro_pelota.y - centro_plataforma.y</p>"},{"location":"Vision%20ppor%20computadora/#4-control-pid","title":"4. Control PID","text":"<p>python output_x = Kperror_x + Kiintegral_x + Kd*derivative_x</p> <p>Sliders en OpenCV permiten ajustar Kp, Ki y Kd.</p>"},{"location":"Vision%20ppor%20computadora/#5-envio-al-esp32","title":"5. Env\u00edo al ESP32","text":"<p>python mensaje = f\"{int(current_x)},{int(current_y)}\\n\" esp32.write(mensaje.encode())</p>"},{"location":"Vision%20ppor%20computadora/#mecanica","title":"Mec\u00e1nica","text":""},{"location":"Vision%20ppor%20computadora/#codigos","title":"C\u00f3digos","text":"<p>Python (Visi\u00f3n por Computadora)</p> <p>python</p> <p>import cv2 import time import numpy as np import serial import serial.tools.list_ports</p>"},{"location":"Vision%20ppor%20computadora/#configuracion-serial-bluetooth","title":"Configuraci\u00f3n Serial Bluetooth","text":"<pre><code>esp32_port = 'COM3'\nbaud_rate = 115200\n\nprint(\"=\" * 50)\nprint(\"Intentando conectar con ESP32...\")\nprint(f\"Puerto: {esp32_port} | Baudios: {baud_rate}\")\n\ndef listar_puertos():\n    puertos = serial.tools.list_ports.comports()\n    print(\"\\n Puertos COM disponibles:\")\n    if len(puertos) == 0:\n        print(\"  No se encontraron puertos COM\")\n    for puerto in puertos:\n        print(f\"   \u2022 {puerto.device}: {puerto.description}\")\n    print()\n\nlistar_puertos()\n\ntry:\n    esp32 = serial.Serial(esp32_port, baud_rate, timeout=1)\n    time.sleep(2)\n    print(f\" \u00a1Conectado al ESP32 en {esp32_port}!\")\nexcept serial.SerialException as e:\n    print(f\" Error de conexi\u00f3n serial: {e}\")\n    print(\"\\n Posibles soluciones:\")\n    print(\"   1. Verifica que el puerto COM sea correcto\")\n    print(\"   2. Cierra el IDE de Arduino si est\u00e1 abierto\")\n    print(\"   3. Cierra cualquier monitor serial activo\")\n    print(\"   4. Desconecta y reconecta el ESP32\")\n    print(\"   5. Verifica que el ESP32 est\u00e9 encendido\")\n    esp32 = None\nexcept Exception as e:\n    print(f\" Error inesperado: {e}\")\n    esp32 = None\n\nprint(\"=\" * 50)\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#configuracion-camara","title":"Configuraci\u00f3n c\u00e1mara","text":"<pre><code>cap = cv2.VideoCapture(1)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\nif not cap.isOpened():\n    print(\"Error: No se pudo abrir la c\u00e1mara\")\n    exit()\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#posicion-inicial-servos","title":"Posici\u00f3n inicial servos","text":"<pre><code>center_angle = 50\ncurrent_x = center_angle\ncurrent_y = center_angle\nDEAD_ZONE = 15  # Zona muerta reducida\nsmoothing = 0.3  # Suavizado reducido para respuesta m\u00e1s r\u00e1pida\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#parametros-pid-ajustables","title":"Par\u00e1metros PID ajustables","text":"<pre><code>Kp = 0.15\nKi = 0.001\nKd = 0.20\n\nprev_error_x = 0\nprev_error_y = 0\nintegral_x = 0\nintegral_y = 0\n\nMAX_INTEGRAL = 50\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#parametros-de-deteccion","title":"Par\u00e1metros de detecci\u00f3n","text":"<pre><code># Threshold para plataforma NEGRA (0-255, valor V en HSV)\nTHRESHOLD_PLATAFORMA = 120  # Ampliado para detectar m\u00e1s tonos\nAREA_MIN_PLATAFORMA = 1000  # \u00c1rea m\u00ednima del cuadrado\n\n# Rango HSV para pelota azul\nLOW_BLUE = np.array([100, 150, 70])\nHIGH_BLUE = np.array([130, 255, 255])\nAREA_MIN_PELOTA = 200\nRADIO_MIN_PELOTA = 8\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#funcion-para-limitar-valores","title":"Funci\u00f3n para limitar valores","text":"<pre><code>def constrain(value, min_val, max_val):\n    return max(min_val, min(max_val, value))\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#callbacks-para-sliders","title":"Callbacks para sliders","text":"<pre><code>def update_kp(val):\n    global Kp\n    Kp = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kp = {Kp:.3f}\")\n\ndef update_ki(val):\n    global Ki\n    Ki = val / 1000.0  # Slider 0-100, valor real 0.000-0.100\n    print(f\"Ki = {Ki:.4f}\")\n\ndef update_kd(val):\n    global Kd\n    Kd = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kd = {Kd:.3f}\")\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#crear-ventana-de-control","title":"Crear ventana de control","text":"<pre><code>cv2.namedWindow('Control PID')\ncv2.createTrackbar('Kp x100', 'Control PID', int(Kp * 100), 100, update_kp)\ncv2.createTrackbar('Ki x1000', 'Control PID', int(Ki * 1000), 100, update_ki)\ncv2.createTrackbar('Kd x100', 'Control PID', int(Kd * 100), 100, update_kd)\n\nprev_time = time.time()\nprint(\"=\" * 50)\nprint(\"Sistema de Balance: Plataforma + Pelota\")\nprint(\"=\" * 50)\nprint(\"CONFIGURACI\u00d3N:\")\nprint(f\"  \u2022 Centro servos: {center_angle}\u00b0 (Rango: 0-180\u00b0)\")\nprint(f\"  \u2022 Zona muerta: \u00b1{DEAD_ZONE} p\u00edxeles\")\nprint(f\"  \u2022 Suavizado: {smoothing}\")\nprint(f\"  \u2022 Threshold plataforma: {THRESHOLD_PLATAFORMA}\")\nprint(f\"  \u2022 PID: Kp={Kp} Ki={Ki} Kd={Kd}\")\nprint(\"\\nDETECCI\u00d3N:\")\nprint(\"  \u2022 PLATAFORMA NEGRA (HSV): Detecta \u00e1rea m\u00e1s grande de tonos oscuros\")\nprint(\"  \u2022 PELOTA AZUL: Posici\u00f3n para calcular error\")\nprint(\"  \u2022 Usa teclas '1'/'2' para ajustar threshold\")\nprint(\"\\nCONTROLES:\")\nprint(\"  \u2022 'q' \u2192 Salir\")\nprint(\"  \u2022 'c' \u2192 Resetear integrales\")\nprint(\"  \u2022 '1' \u2192 Threshold -5\")\nprint(\"  \u2022 '2' \u2192 Threshold +5\")\nprint(\"  \u2022 Sliders \u2192 Ajustar PID en tiempo real\")\nprint(\"=\" * 50)\n\nframe_count = 0\nfps_time = time.time()\nfps = 0\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        print(\"Error: No se pudo leer frame de la c\u00e1mara\")\n        break\n\n    frame = cv2.flip(frame, 1)\n    height, width = frame.shape[:2]\n    centrox, centroy = width//2, height//2\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#deteccion-1-plataforma-negra-hsv-area-mas-grande","title":"DETECCI\u00d3N 1: PLATAFORMA NEGRA (HSV) - \u00c1REA M\u00c1S GRANDE","text":"<pre><code>    hsv_plat = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n    lower_black = np.array([0, 0, 0])\n    upper_black = np.array([180, 255, THRESHOLD_PLATAFORMA])\n\n    mask_plataforma = cv2.inRange(hsv_plat, lower_black, upper_black)\n\n    kernel_plat = np.ones((7,7), np.uint8)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_CLOSE, kernel_plat)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_OPEN, kernel_plat)\n    mask_plataforma = cv2.dilate(mask_plataforma, kernel_plat, iterations=1)\n\n    contours_plat, _ = cv2.findContours(mask_plataforma, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_plat = 0\n    contorno_plat = None\n    centro_plataforma = None\n    rectangulo_info = None\n\n    for c in contours_plat:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_plat and area &gt; AREA_MIN_PLATAFORMA:\n            area_max_plat = area\n            contorno_plat = c\n            rectangulo_info = cv2.minAreaRect(c)\n\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx_plat = int(M[\"m10\"] / M[\"m00\"])\n                cy_plat = int(M[\"m01\"] / M[\"m00\"])\n                centro_plataforma = (cx_plat, cy_plat)\n ```\n### DETECCI\u00d3N 2: PELOTA AZUL\n```bash\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask_pelota = cv2.inRange(hsv, LOW_BLUE, HIGH_BLUE)\n\n    kernel_pelota = np.ones((5,5), np.uint8)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_OPEN, kernel_pelota)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_CLOSE, kernel_pelota)\n    mask_pelota = cv2.dilate(mask_pelota, kernel_pelota, iterations=1)\n\n    contours_pelota, _ = cv2.findContours(mask_pelota, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_pelota = 0\n    contorno_pelota = None\n    centro_pelota = None\n    radio_pelota = 0\n\n    for c in contours_pelota:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_pelota:\n            area_max_pelota = area\n            contorno_pelota = c\n            (x_pel, y_pel), radio_pelota = cv2.minEnclosingCircle(c)\n            if radio_pelota &gt; RADIO_MIN_PELOTA and area &gt; AREA_MIN_PELOTA:\n                centro_pelota = (int(x_pel), int(y_pel))\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#visualizacion","title":"VISUALIZACI\u00d3N","text":"<pre><code>    out_original = frame.copy()\n\n    mask_combinada = cv2.bitwise_or(mask_plataforma, mask_pelota)\n    out_deteccion = cv2.cvtColor(mask_combinada, cv2.COLOR_GRAY2BGR)\n\n    out_deteccion[mask_plataforma &gt; 0] = [255, 0, 0]\n    out_deteccion[mask_pelota &gt; 0] = [0, 255, 255]\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#calcular-tiempo","title":"CALCULAR TIEMPO","text":"<pre><code>    current_time = time.time()\n    dt = current_time - prev_time\n    prev_time = current_time\n    if dt &lt; 0.001:\n        dt = 0.001\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#control-pid-solo-cambio-error-x","title":"CONTROL PID - SOLO CAMBIO: ERROR X","text":"<pre><code>    plataforma_detectada = (contorno_plat is not None and area_max_plat &gt; AREA_MIN_PLATAFORMA and centro_plataforma is not None)\n    pelota_detectada = (contorno_pelota is not None and centro_pelota is not None)\n\n    if plataforma_detectada:\n        if rectangulo_info:\n            box = cv2.boxPoints(rectangulo_info)\n            box = np.intp(box)\n            cv2.drawContours(out_original, [box], 0, (0, 255, 0), 3)\n            cv2.drawContours(out_deteccion, [box], 0, (0, 255, 0), 2)\n\n        cv2.circle(out_original, centro_plataforma, 12, (0, 255, 0), 3)\n        cv2.circle(out_original, centro_plataforma, 5, (0, 255, 0), -1)\n        cv2.putText(out_original, \"PLATAFORMA\", (centro_plataforma[0]-40, centro_plataforma[1]-20),\n                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)\n\n        if pelota_detectada:\n            cv2.circle(out_original, centro_pelota, int(radio_pelota), (0, 255, 255), 2)\n            cv2.circle(out_original, centro_pelota, 5, (255, 0, 0), -1)\n            cv2.putText(out_original, \"PELOTA\", (centro_pelota[0]-30, centro_pelota[1]+25),\n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)\n            QQQ\n            cv2.line(out_original, centro_plataforma, centro_pelota, (255, 0, 255), 2)\n            cv2.line(out_deteccion, centro_plataforma, centro_pelota, (255, 255, 255), 2)\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#calcular-error-pelota-respecto-al-centro-de-la-plataforma","title":"CALCULAR ERROR: Pelota respecto al centro de la plataforma","text":"<p>SOLO CAMBIO: X sin signo negativo <pre><code>            error_x = (centro_pelota[0] - centro_plataforma[0])  # CORREGIDO X\n            error_y = (centro_pelota[1] - centro_plataforma[1])  # Y sigue invertido\n\n            if abs(error_x) &lt; DEAD_ZONE: \n                error_x = 0\n            if abs(error_y) &lt; DEAD_ZONE: \n                error_y = 0\n\n            integral_x += error_x * dt\n            integral_y += error_y * dt\n            integral_x = constrain(integral_x, -MAX_INTEGRAL, MAX_INTEGRAL)\n            integral_y = constrain(integral_y, -MAX_INTEGRAL, MAX_INTEGRAL)\n\n            derivative_x = (error_x - prev_error_x) / dt\n            derivative_y = (error_y - prev_error_y) / dt\n\n            output_x = Kp*error_x + Ki*integral_x + Kd*derivative_x\n            output_y = Kp*error_y + Ki*integral_y + Kd*derivative_y\n\n            prev_error_x = error_x\n            prev_error_y = error_y\n\n            delta_x = output_x * 0.15\n            delta_y = output_y * 0.15\n\n            target_x = center_angle + delta_x\n            target_y = center_angle + delta_y\n\n            current_x = current_x * (1 - smoothing) + target_x * smoothing\n            current_y = current_y * (1 - smoothing) + target_y * smoothing\n\n            current_x = constrain(current_x, 0, 110)\n            current_y = constrain(current_y, 0, 110)\n\n            if esp32:\n                mensaje = f\"{int(current_x)},{int(current_y)}\\n\"\n                try:\n                    esp32.write(mensaje.encode())\n                    if esp32.in_waiting &gt; 0:\n                        respuesta = esp32.readline().decode('utf-8', errors='ignore').strip()\n                        if respuesta and frame_count % 30 == 0:\n                            print(f\"\ud83d\udce1 ESP32: {respuesta}\")\n                except Exception as e:\n                    if frame_count % 30 == 0:\n                        print(f\"\u2717 Error: {e}\")\n\n            if frame_count % 5 == 0:\n                print(f\"\u2713 X={int(current_x):3d}\u00b0 Y={int(current_y):3d}\u00b0 | Err X={-error_x:4d} Y={-error_y:4d} | Out X={output_x:6.1f} Y={output_y:6.1f}\")\n\n            cv2.putText(out_original, f\"Error X:{-error_x} Y:{-error_y}\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Servo X:{int(current_x)} Y:{int(current_y)}\", (10,60),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Distancia: {int(np.sqrt(error_x**2 + error_y**2))} px\", (10,90),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,255), 2)\n        else:\n            cv2.putText(out_original, \"PELOTA NO DETECTADA\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,165,255), 2)\n\n            integral_x = 0\n            integral_y = 0\n            prev_error_x = 0\n            prev_error_y = 0\n\n            current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n            current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n            if esp32 and frame_count % 10 == 0:\n                try:\n                    esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n                except:\n                    pass\n\n            if frame_count % 30 == 0:\n                print(f\" Solo plataforma. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n    else:\n        cv2.putText(out_original, \"PLATAFORMA NO DETECTADA\", (10,30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n        integral_x = 0\n        integral_y = 0\n        prev_error_x = 0\n        prev_error_y = 0\n\n        current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n        current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n        if esp32 and frame_count % 10 == 0:\n            try:\n                esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n            except:\n                pass\n\n        if frame_count % 30 == 0:\n            print(f\" Sin detecci\u00f3n. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n\n    cv2.circle(out_original, (centrox, centroy), DEAD_ZONE, (128,128,128), 1)\n    cv2.line(out_original, (centrox-15, centroy), (centrox+15, centroy), (128,128,128), 1)\n    cv2.line(out_original, (centrox, centroy-15), (centrox, centroy+15), (128,128,128), 1)\n\n    cv2.putText(out_original, f\"Plat:{int(area_max_plat)} Pel:{int(area_max_pelota)}\", (10,height-40),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\n    cv2.putText(out_original, f\"Threshold:{THRESHOLD_PLATAFORMA} (1/2)\", (10,height-15),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\n\n    cv2.putText(out_original, f\"PID: Kp={Kp:.2f} Ki={Ki:.3f} Kd={Kd:.2f}\", (10,120),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,200,0), 2)\n\n    frame_count += 1\n    if time.time() - fps_time &gt; 1.0:\n        fps = frame_count\n        frame_count = 0\n        fps_time = time.time()\n\n    cv2.putText(out_original, f\"FPS: {fps}\", (width-100, 30),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n\n    cv2.imshow(\"Sistema de Balance - Original\", out_original)\n    cv2.imshow(\"Deteccion: Plataforma(Azul) + Pelota(Amarillo)\", out_deteccion)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        integral_x = 0\n        integral_y = 0\n        print(\"Integrales reseteadas\")\n    elif key == ord('1'):\n        THRESHOLD_PLATAFORMA = max(10, THRESHOLD_PLATAFORMA - 5)\n        print(f\"Threshold: {THRESHOLD_PLATAFORMA}\")\n    elif key == ord('2'):\n        THRESHOLD_PLATAFORMA = min(250, THRESHOLD_PLATAFORMA + 5)\n        print(f\"Threshold: {THRESHOLD_PLATAFORMA}\")\n\nprint(\"\\nCerrando sistema...\")\ncap.release()\nif esp32:\n    esp32.write(f\"{center_angle},{center_angle}\\n\".encode())\n    time.sleep(0.1)\n    esp32.close()\n    print(\"Conexi\u00f3n serial cerrada\")\ncv2.destroyAllWindows()\nprint(\"Sistema finalizado\")\n</code></pre></p>"},{"location":"Vision%20ppor%20computadora/#codigo-esp32-arduino","title":"C\u00f3digo ESP32 / Arduino","text":"<pre><code>cpp\n#include &lt;ESP32Servo.h&gt;\n\n// =============== CONFIGURACI\u00d3N DE PINES ===============\nconst int PIN_SERVO_X = 18;  // Servo que controla eje X (horizontal)\nconst int PIN_SERVO_Y = 19;  // Servo que controla eje Y (vertical)\n\n// =============== CONFIGURACI\u00d3N DE SERVOS ===============\nServo servoX;\nServo servoY;\n\n// Par\u00e1metros PWM para servos (ajustar seg\u00fan tu modelo)\nconst int PWM_MIN = 500;   // Ancho de pulso m\u00ednimo en microsegundos\nconst int PWM_MAX = 2400;  // Ancho de pulso m\u00e1ximo en microsegundos\n\n// =============== POSICI\u00d3N INICIAL ===============\nconst int CENTRO = 35;     // Posici\u00f3n central (0-180 grados)\n\n// =============== VARIABLES DE COMUNICACI\u00d3N ===============\nString inputString = \"\";         // Buffer para datos recibidos\nbool stringComplete = false;     // Bandera de comando completo\n\n// =============== VARIABLES DE CONTROL ===============\nint posicionX = CENTRO;\nint posicionY = CENTRO;\nunsigned long ultimoComando = 0;\nconst unsigned long TIMEOUT = 2000;  // Timeout en ms (volver al centro si no hay datos)\n\n// =============== CONFIGURACI\u00d3N INICIAL ===============\nvoid setup() {\n  // Iniciar comunicaci\u00f3n serial\n  Serial.begin(115200);\n\n  // Reservar memoria para el buffer\n  inputString.reserve(20);\n\n  // Configurar servos con par\u00e1metros PWM personalizados\n  servoX.attach(PIN_SERVO_X, PWM_MIN, PWM_MAX);\n  servoY.attach(PIN_SERVO_Y, PWM_MIN, PWM_MAX);\n\n  // Mover a posici\u00f3n inicial centrada\n  servoX.write(CENTRO);\n  servoY.write(CENTRO);\n\n  // Esperar estabilizaci\u00f3n\n  delay(500);\n\n  // Mensaje de inicio\n  Serial.println(\"========================================\");\n  Serial.println(\"ESP32 - Sistema de Balance de Pelota\");\n  Serial.println(\"========================================\");\n  Serial.println(\"Configuracion:\");\n  Serial.print(\"  - Servo X en pin GPIO \");\n  Serial.println(PIN_SERVO_X);\n  Serial.print(\"  - Servo Y en pin GPIO \");\n  Serial.println(PIN_SERVO_Y);\n  Serial.print(\"  - Centro: \");\n  Serial.print(CENTRO);\n  Serial.println(\" grados\");\n  Serial.print(\"  - PWM: \");\n  Serial.print(PWM_MIN);\n  Serial.print(\"-\");\n  Serial.print(PWM_MAX);\n  Serial.println(\" us\");\n  Serial.println(\"========================================\");\n  Serial.println(\"Sistema listo. Esperando datos...\");\n  Serial.println(\"Formato: X,Y (ejemplo: 90,85)\");\n  Serial.println(\"========================================\");\n\n  ultimoComando = millis();\n}\n\n// =============== BUCLE PRINCIPAL ===============\nvoid loop() {\n  // Leer datos seriales disponibles\n  while (Serial.available()) {\n    char inChar = (char)Serial.read();\n\n    // Si es salto de l\u00ednea, el comando est\u00e1 completo\n    if (inChar == '\\n' || inChar == '\\r') {\n      if (inputString.length() &gt; 0) {\n        stringComplete = true;\n      }\n    } else {\n      // Agregar caracter al buffer\n      inputString += inChar;\n    }\n  }\n\n  // Procesar comando si est\u00e1 completo\n  if (stringComplete) {\n    procesarComando();\n    inputString = \"\";\n    stringComplete = false;\n    ultimoComando = millis();\n  }\n\n  // Timeout: volver al centro si no hay comandos recientes\n  if (millis() - ultimoComando &gt; TIMEOUT) {\n    volverAlCentro();\n    ultimoComando = millis();\n  }\n}\n\n// =============== FUNCI\u00d3N: PROCESAR COMANDO ===============\nvoid procesarComando() {\n  // Buscar la coma separadora\n  int comaIndex = inputString.indexOf(',');\n\n  if (comaIndex &gt; 0) {\n    // Extraer valores X e Y\n    String valorXStr = inputString.substring(0, comaIndex);\n    String valorYStr = inputString.substring(comaIndex + 1);\n\n    // Convertir a enteros\n    int xRecibido = valorXStr.toInt();\n    int yRecibido = valorYStr.toInt();\n\n    // Validar y limitar al rango 0-180\n    xRecibido = constrain(xRecibido, 0, 180);\n    yRecibido = constrain(yRecibido, 0, 180);\n\n    // Actualizar posiciones\n    posicionX = xRecibido;\n    posicionY = yRecibido;\n\n    // Mover servos\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    // Enviar confirmaci\u00f3n a Python\n    Serial.print(\"Recibido: \");\n    Serial.print(posicionX);\n    Serial.print(\",\");\n    Serial.println(posicionY);\n\n  } else {\n    // Comando inv\u00e1lido (sin coma)\n    Serial.print(\"Error: Formato invalido '\");\n    Serial.print(inputString);\n    Serial.println(\"'. Use: X,Y\");\n  }\n}\n\n// =============== FUNCI\u00d3N: VOLVER AL CENTRO ===============\nvoid volverAlCentro() {\n  static bool mensajeMostrado = false;\n\n  // Movimiento suave hacia el centro\n  if (posicionX != CENTRO || posicionY != CENTRO) {\n    if (!mensajeMostrado) {\n      Serial.println(\"Timeout: Volviendo al centro...\");\n      mensajeMostrado = true;\n    }\n\n    // Acercar gradualmente al centro\n    if (posicionX &lt; CENTRO) posicionX++;\n    if (posicionX &gt; CENTRO) posicionX--;\n    if (posicionY &lt; CENTRO) posicionY++;\n    if (posicionY &gt; CENTRO) posicionY--;\n\n    // Mover servos\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    delay(20);  // Movimiento suave\n  } else {\n    mensajeMostrado = false;\n  }\n}\n</code></pre>"},{"location":"Vision%20ppor%20computadora/#instalacion-y-uso","title":"Instalaci\u00f3n y Uso","text":"<ol> <li>Cargar el c\u00f3digo en el ESP32.</li> <li>Ejecutar el script de Python.</li> <li>Verificar que la c\u00e1mara detecte la plataforma.</li> <li>Ajustar par\u00e1metros PID con los sliders.</li> <li>Colocar la pelota sobre la plataforma.</li> <li>Observar la estabilizaci\u00f3n en tiempo real.</li> </ol>"},{"location":"Vision%20ppor%20computadora/#conclusiones","title":"Conclusiones","text":"<ul> <li>El robot utiliza visi\u00f3n artificial para estimar posici\u00f3n.</li> <li>El PID corrige la inclinaci\u00f3n con alta precisi\u00f3n.</li> <li>La estructura mec\u00e1nica y servos de alto torque permiten estabilidad.</li> <li>Se obtuvo un robot funcional capaz de mantener el equilibrio de una pelota.</li> </ul>"},{"location":"Vision%20ppor%20computadora/#licencia","title":"Licencia","text":"<p>Proyecto acad\u00e9mico desarrollado para fines\u00a0educativos.</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}